// Generated by mpv-libretro

//!PARAM BRIGHTNESS
//!DESC Brightness
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 2
1.5

//!PARAM GAMMA_INPUT
//!DESC Gamma Input
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 5
2.4

//!PARAM GAMMA_OUTPUT
//!DESC Gamma Output
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 5
2.4

//!PARAM GLOW_DIFFUSION
//!DESC Glow Diffusion
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0.05

//!PARAM GLOW_HALATION
//!DESC Glow Halation
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0.1

//!PARAM GLOW_HEIGHT
//!DESC Glow Height
//!TYPE CONSTANT float
//!MINIMUM 0.05
//!MAXIMUM 0.65
0.5

//!PARAM GLOW_WIDTH
//!DESC Glow Width
//!TYPE CONSTANT float
//!MINIMUM 0.05
//!MAXIMUM 0.65
0.5

//!PARAM MASK_COLORS
//!DESC Mask Colors
//!TYPE CONSTANT float
//!MINIMUM 2
//!MAXIMUM 3
2

//!PARAM MASK_SIZE
//!DESC Mask Size
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 9
1

//!PARAM MASK_STRENGTH
//!DESC Mask Strength
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0.3

//!PARAM SCANLINE_OFFSET
//!DESC Scanline Offset
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
1

//!PARAM SCANLINE_SHAPE
//!DESC Scanline Shape
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 100
2.5

//!PARAM SCANLINE_SIZE_MAX
//!DESC Scanline Size Max.
//!TYPE CONSTANT float
//!MINIMUM 0.5
//!MAXIMUM 1.5
1.5

//!PARAM SCANLINE_SIZE_MIN
//!DESC Scanline Size Min.
//!TYPE CONSTANT float
//!MINIMUM 0.5
//!MAXIMUM 1.5
0.5

//!PARAM SHARPNESS_EDGES
//!DESC Sharpness Edges
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 5
3

//!PARAM SHARPNESS_IMAGE
//!DESC Sharpness Image
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 5
1

//!HOOK MAIN
//!COMPONENTS 4
//!DESC sRGB to linear RGB
//!SAVE MAIN_RGB
//!BIND HOOKED

vec4 hook() {
	return linearize(HOOKED_tex(HOOKED_pos));
}

//!HOOK MAIN
//!COMPONENTS 4
//!DESC crt-aperture.slang
//!WIDTH OUTPUT.width 1 *
//!HEIGHT OUTPUT.height 1 *
//!BIND MAIN_RGB
//!BIND HOOKED

vec4 vertex_gl_Position;
struct _params_ {
    vec4 SourceSize;
    vec4 OutputSize;
    uint FrameCount;
    float SHARPNESS_IMAGE;
    float SHARPNESS_EDGES;
    float GLOW_WIDTH;
    float GLOW_HEIGHT;
    float GLOW_HALATION;
    float GLOW_DIFFUSION;
    float MASK_COLORS;
    float MASK_STRENGTH;
    float MASK_SIZE;
    float SCANLINE_SIZE_MIN;
    float SCANLINE_SIZE_MAX;
    float SCANLINE_SHAPE;
    float SCANLINE_OFFSET;
    float GAMMA_INPUT;
    float GAMMA_OUTPUT;
    float BRIGHTNESS;
} params = _params_(vec4(MAIN_RGB_size, MAIN_RGB_pt), vec4(target_size, 1. / target_size.x, 1. / target_size.y), uint(frame), float(SHARPNESS_IMAGE), float(SHARPNESS_EDGES), float(GLOW_WIDTH), float(GLOW_HEIGHT), float(GLOW_HALATION), float(GLOW_DIFFUSION), float(MASK_COLORS), float(MASK_STRENGTH), float(MASK_SIZE), float(SCANLINE_SIZE_MIN), float(SCANLINE_SIZE_MAX), float(SCANLINE_SHAPE), float(SCANLINE_OFFSET), float(GAMMA_INPUT), float(GAMMA_OUTPUT), float(BRIGHTNESS));
struct _global_ {
    mat4 MVP;
} global = _global_(mat4(1.));
mat3x3 vertex_get_color_matrix(sampler2D tex, vec2 co, vec2 dx) {
    return mat3x3(pow(texture(tex, co - dx).rgb, vec3(params.GAMMA_INPUT)), pow(texture(tex, co).rgb, vec3(params.GAMMA_INPUT)), pow(texture(tex, co + dx).rgb, vec3(params.GAMMA_INPUT)));
}

vec3 vertex_blur(mat3 m, float dist, float rad) {
    vec3 x = vec3(dist - 1., dist, dist + 1.) / rad;
    vec3 w = exp2(x * x * -1.);
    return (m[0] * w.x + m[1] * w.y + m[2] * w.z) / (w.x + w.y + w.z);
}

vec3 vertex_filter_gaussian(sampler2D tex, vec2 co, vec2 tex_size) {
    vec2 dx = vec2(1. / tex_size.x, 0.);
    vec2 dy = vec2(0., 1. / tex_size.y);
    vec2 pix_co = co * tex_size;
    vec2 tex_co = (floor(pix_co) + 0.5) / tex_size;
    vec2 dist = (fract(pix_co) - 0.5) * -1.;
    mat3x3 line0 = vertex_get_color_matrix(tex, tex_co - dy, dx);
    mat3x3 line1 = vertex_get_color_matrix(tex, tex_co, dx);
    mat3x3 line2 = vertex_get_color_matrix(tex, tex_co + dy, dx);
    mat3x3 column = mat3x3(vertex_blur(line0, dist.x, params.GLOW_WIDTH), vertex_blur(line1, dist.x, params.GLOW_WIDTH), vertex_blur(line2, dist.x, params.GLOW_WIDTH));
    return vertex_blur(column, dist.y, params.GLOW_HEIGHT);
}

vec3 vertex_filter_lanczos(sampler2D tex, vec2 co, vec2 tex_size, float sharp) {
    tex_size.x *= sharp;
    vec2 dx = vec2(1. / tex_size.x, 0.);
    vec2 pix_co = co * tex_size - vec2(0.5, 0.);
    vec2 tex_co = (floor(pix_co) + vec2(0.5, 0.001)) / tex_size;
    vec2 dist = fract(pix_co);
    vec4 coef = 3.1415927 * vec4(dist.x + 1., dist.x, dist.x - 1., dist.x - 2.);
    coef = max(abs(coef), 0.00001);
    coef = 2. * sin(coef) * sin(coef / 2.) / (coef * coef);
    coef /= dot(coef, vec4(1.));
    vec4 col1 = vec4(pow(texture(tex, tex_co).rgb, vec3(params.GAMMA_INPUT)), 1.);
    vec4 col2 = vec4(pow(texture(tex, tex_co + dx).rgb, vec3(params.GAMMA_INPUT)), 1.);
    return (mat4x4(col1, col1, col2, col2) * coef).rgb;
}

vec3 vertex_get_scanline_weight(float x, vec3 col) {
    vec3 beam = mix(vec3(params.SCANLINE_SIZE_MIN), vec3(params.SCANLINE_SIZE_MAX), pow(col, vec3(1. / params.SCANLINE_SHAPE)));
    vec3 x_mul = 2. / beam;
    vec3 x_offset = x_mul * 0.5;
    return smoothstep(0., 1., 1. - abs(x * x_mul - x_offset)) * x_offset;
}

vec3 vertex_get_mask_weight(float x) {
    float i = mod(floor(x * params.OutputSize.x * params.SourceSize.x / (params.SourceSize.x * params.MASK_SIZE)), params.MASK_COLORS);
    if (i == 0.) return mix(vec3(1., 0., 1.), vec3(1., 0., 0.), params.MASK_COLORS - 2.); else if (i == 1.) return vec3(0., 1., 0.); else return vec3(0., 0., 1.);
}

vec4 Position = vec4(HOOKED_pos, 0., 1.);
vec2 TexCoord = HOOKED_pos;
vec2 vTexCoord;
void vertex_main() {
    vertex_gl_Position = global.MVP * Position;
    vTexCoord = TexCoord;
}

mat3x3 fragment_get_color_matrix(sampler2D tex, vec2 co, vec2 dx) {
    return mat3x3(pow(texture(tex, co - dx).rgb, vec3(params.GAMMA_INPUT)), pow(texture(tex, co).rgb, vec3(params.GAMMA_INPUT)), pow(texture(tex, co + dx).rgb, vec3(params.GAMMA_INPUT)));
}

vec3 fragment_blur(mat3 m, float dist, float rad) {
    vec3 x = vec3(dist - 1., dist, dist + 1.) / rad;
    vec3 w = exp2(x * x * -1.);
    return (m[0] * w.x + m[1] * w.y + m[2] * w.z) / (w.x + w.y + w.z);
}

vec3 fragment_filter_gaussian(sampler2D tex, vec2 co, vec2 tex_size) {
    vec2 dx = vec2(1. / tex_size.x, 0.);
    vec2 dy = vec2(0., 1. / tex_size.y);
    vec2 pix_co = co * tex_size;
    vec2 tex_co = (floor(pix_co) + 0.5) / tex_size;
    vec2 dist = (fract(pix_co) - 0.5) * -1.;
    mat3x3 line0 = fragment_get_color_matrix(tex, tex_co - dy, dx);
    mat3x3 line1 = fragment_get_color_matrix(tex, tex_co, dx);
    mat3x3 line2 = fragment_get_color_matrix(tex, tex_co + dy, dx);
    mat3x3 column = mat3x3(fragment_blur(line0, dist.x, params.GLOW_WIDTH), fragment_blur(line1, dist.x, params.GLOW_WIDTH), fragment_blur(line2, dist.x, params.GLOW_WIDTH));
    return fragment_blur(column, dist.y, params.GLOW_HEIGHT);
}

vec3 fragment_filter_lanczos(sampler2D tex, vec2 co, vec2 tex_size, float sharp) {
    tex_size.x *= sharp;
    vec2 dx = vec2(1. / tex_size.x, 0.);
    vec2 pix_co = co * tex_size - vec2(0.5, 0.);
    vec2 tex_co = (floor(pix_co) + vec2(0.5, 0.001)) / tex_size;
    vec2 dist = fract(pix_co);
    vec4 coef = 3.1415927 * vec4(dist.x + 1., dist.x, dist.x - 1., dist.x - 2.);
    coef = max(abs(coef), 0.00001);
    coef = 2. * sin(coef) * sin(coef / 2.) / (coef * coef);
    coef /= dot(coef, vec4(1.));
    vec4 col1 = vec4(pow(texture(tex, tex_co).rgb, vec3(params.GAMMA_INPUT)), 1.);
    vec4 col2 = vec4(pow(texture(tex, tex_co + dx).rgb, vec3(params.GAMMA_INPUT)), 1.);
    return (mat4x4(col1, col1, col2, col2) * coef).rgb;
}

vec3 fragment_get_scanline_weight(float x, vec3 col) {
    vec3 beam = mix(vec3(params.SCANLINE_SIZE_MIN), vec3(params.SCANLINE_SIZE_MAX), pow(col, vec3(1. / params.SCANLINE_SHAPE)));
    vec3 x_mul = 2. / beam;
    vec3 x_offset = x_mul * 0.5;
    return smoothstep(0., 1., 1. - abs(x * x_mul - x_offset)) * x_offset;
}

vec3 fragment_get_mask_weight(float x) {
    float i = mod(floor(x * params.OutputSize.x * params.SourceSize.x / (params.SourceSize.x * params.MASK_SIZE)), params.MASK_COLORS);
    if (i == 0.) return mix(vec3(1., 0., 1.), vec3(1., 0., 0.), params.MASK_COLORS - 2.); else if (i == 1.) return vec3(0., 1., 0.); else return vec3(0., 0., 1.);
}

vec4 FragColor;
#define Source MAIN_RGB_raw
void fragment_main() {
    float scale = floor(params.OutputSize.y * params.SourceSize.w);
    float offset = 1. / scale * 0.5;
    if (bool(mod(scale, 2.))) offset = 0.;
    vec2 co = (vTexCoord * params.SourceSize.xy - vec2(0., offset * params.SCANLINE_OFFSET)) * params.SourceSize.zw;
    vec3 col_glow = fragment_filter_gaussian(Source, co, params.SourceSize.xy);
    vec3 col_soft = fragment_filter_lanczos(Source, co, params.SourceSize.xy, params.SHARPNESS_IMAGE);
    vec3 col_sharp = fragment_filter_lanczos(Source, co, params.SourceSize.xy, params.SHARPNESS_EDGES);
    vec3 col = sqrt(col_sharp * col_soft);
    col *= fragment_get_scanline_weight(fract(co.y * params.SourceSize.y), col_soft);
    col_glow = clamp(col_glow - col, 0., 1.);
    col += col_glow * col_glow * params.GLOW_HALATION;
    col = mix(col, col * fragment_get_mask_weight(vTexCoord.x) * params.MASK_COLORS, params.MASK_STRENGTH);
    col += col_glow * params.GLOW_DIFFUSION;
    col = pow(col * params.BRIGHTNESS, vec3(1. / params.GAMMA_OUTPUT));
    FragColor = vec4(col, 1.);
}

vec4 hook() {
    vertex_main();
    fragment_main();
    return delinearize(FragColor);
}

