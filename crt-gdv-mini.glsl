// Generated by mpv-libretro

//!PARAM CGWG
//!DESC CGWG Mask Str.
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0.3

//!PARAM beam_max
//!DESC Scanline Bright
//!TYPE CONSTANT float
//!MINIMUM 0.5
//!MAXIMUM 3
1.05

//!PARAM beam_min
//!DESC Scanline Dark
//!TYPE CONSTANT float
//!MINIMUM 0.5
//!MAXIMUM 3
1.35

//!PARAM brightboost
//!DESC Bright boost
//!TYPE CONSTANT float
//!MINIMUM 0.5
//!MAXIMUM 2
1

//!PARAM gamma_out
//!DESC Gamma out
//!TYPE CONSTANT float
//!MINIMUM 0.2
//!MAXIMUM 0.6
0.5

//!PARAM gdv_mini_title
//!DESC [ GDV MINI - DariusG ]:
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0

//!PARAM h_sharp
//!DESC Horizontal Sharpness
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 5
2

//!PARAM maskDark
//!DESC Lottes maskDark
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 2
0.5

//!PARAM maskLight
//!DESC Lottes maskLight
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 2
1.5

//!PARAM masksize
//!DESC CRT Mask Size (2.0 is nice in 4k)
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 2
1

//!PARAM mcut
//!DESC Mask 5-7-10 cutoff
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 0.5
0.2

//!PARAM sat
//!DESC Saturation adjustment
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 2
1

//!PARAM scanline
//!DESC Scanline Adjust
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 12
8

//!PARAM shadowMask
//!DESC CRT Mask: 0:CGWG, 1-4:Lottes, 5-6:Trinitron
//!TYPE CONSTANT float
//!MINIMUM -1
//!MAXIMUM 10
0

//!PARAM vignette
//!DESC Vignette On/Off
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0

//!PARAM warpX
//!DESC CurvatureX (default 0.03)
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 0.25
0

//!PARAM warpY
//!DESC CurvatureY (default 0.04)
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 0.25
0

//!HOOK MAIN
//!COMPONENTS 4
//!DESC sRGB to linear RGB
//!SAVE MAIN_RGB
//!BIND HOOKED

vec4 hook() {
	return linearize(HOOKED_tex(HOOKED_pos));
}

//!HOOK MAIN
//!COMPONENTS 2
//!DESC store viewport size
//!SAVE VIEWPORT
//!WIDTH OUTPUT.width
//!HEIGHT OUTPUT.width

vec4 hook() {
	return vec4(target_size, 0.0, 0.0);
}

//!HOOK MAIN
//!COMPONENTS 4
//!DESC crt-gdv-mini.slang
//!WIDTH OUTPUT.width 1 *
//!HEIGHT OUTPUT.height 1 *
//!BIND MAIN_RGB
//!BIND VIEWPORT
//!BIND HOOKED

vec4 vertex_gl_Position;
struct _params_ {
    vec4 SourceSize;
    vec4 OriginalSize;
    vec4 OutputSize;
    float brightboost;
    float sat;
    float scanline;
    float beam_min;
    float beam_max;
    float h_sharp;
    float shadowMask;
    float masksize;
    float mcut;
    float maskDark;
    float maskLight;
    float CGWG;
    float warpX;
    float warpY;
    float gamma_out;
    float vignette;
} params = _params_(vec4(MAIN_RGB_size, MAIN_RGB_pt), vec4(MAIN_RGB_size, MAIN_RGB_pt), vec4(target_size, 1. / target_size.x, 1. / target_size.y), float(brightboost), float(sat), float(scanline), float(beam_min), float(beam_max), float(h_sharp), float(shadowMask), float(masksize), float(mcut), float(maskDark), float(maskLight), float(CGWG), float(warpX), float(warpY), float(gamma_out), float(vignette));
struct _global_ {
    mat4 MVP;
    vec4 FinalViewportSize;
    vec4 OutputSize;
} global = _global_(mat4(1.), vec4(VIEWPORT_size, VIEWPORT_pt), vec4(target_size, 1. / target_size.x, 1. / target_size.y));
vec4 Position = vec4(HOOKED_pos, 0., 1.);
vec2 TexCoord = HOOKED_pos;
vec2 vTexCoord;
void vertex_main() {
    vertex_gl_Position = global.MVP * Position;
    vTexCoord = TexCoord * 1.0001;
}

vec4 FragColor;
#define Source MAIN_RGB_raw
float fragment_sw(float y, float l, float v) {
    float scan = mix(params.scanline - 2., params.scanline, y);
    float tmp = mix(params.beam_min + v, params.beam_max + v, l);
    float ex = y * tmp;
    return exp2(-scan * ex * ex);
}

vec3 fragment_Mask(vec2 pos, vec3 c) {
    pos = floor(pos / params.masksize);
    vec3 mask = vec3(params.maskDark, params.maskDark, params.maskDark);
    if (params.shadowMask == -1.) {
        mask = vec3(1.);
    } else if (params.shadowMask == 0.) {
        pos.x = fract(pos.x * 0.5);
        float mc = 1. - params.CGWG;
        if (pos.x < 0.5) {
            mask.r = 1.1;
            mask.g = mc;
            mask.b = 1.1;
        } else {
            mask.r = mc;
            mask.g = 1.1;
            mask.b = mc;
        }
    } else if (params.shadowMask == 1.) {
        float line = params.maskLight;
        float odd = 0.;
        if (fract(pos.x / 6.) < 0.5) odd = 1.;
        if (fract((pos.y + odd) / 2.) < 0.5) line = params.maskDark;
        pos.x = fract(pos.x / 3.);
        if (pos.x < 0.333) mask.b = params.maskLight; else if (pos.x < 0.666) mask.g = params.maskLight; else mask.r = params.maskLight;
        mask *= line;
    } else if (params.shadowMask == 2.) {
        pos.x = fract(pos.x / 3.);
        if (pos.x < 0.333) mask.b = params.maskLight; else if (pos.x < 0.666) mask.g = params.maskLight; else mask.r = params.maskLight;
    } else if (params.shadowMask == 3.) {
        pos.x += pos.y * 3.;
        pos.x = fract(pos.x / 6.);
        if (pos.x < 0.333) mask.b = params.maskLight; else if (pos.x < 0.666) mask.g = params.maskLight; else mask.r = params.maskLight;
    } else if (params.shadowMask == 4.) {
        pos.xy = floor(pos.xy * vec2(1., 0.5));
        pos.x += pos.y * 3.;
        pos.x = fract(pos.x / 6.);
        if (pos.x < 0.333) mask.b = params.maskLight; else if (pos.x < 0.666) mask.g = params.maskLight; else mask.r = params.maskLight;
    } else if (params.shadowMask == 5.) {
        float mx = max(max(c.r, c.g), c.b);
        vec3 maskTmp = vec3(min(1.25 * max(mx - params.mcut, 0.) / (1. - params.mcut), params.maskDark + 0.2 * (1. - params.maskDark) * mx));
        float adj = 0.8 * params.maskLight - 0.5 * (0.8 * params.maskLight - 1.) * mx + 0.75 * (1. - mx);
        mask = maskTmp;
        pos.x = fract(pos.x / 2.);
        if (pos.x < 0.5) {
            mask.r = adj;
            mask.b = adj;
        } else mask.g = adj;
    } else if (params.shadowMask == 6.) {
        float mx = max(max(c.r, c.g), c.b);
        vec3 maskTmp = vec3(min(1.33 * max(mx - params.mcut, 0.) / (1. - params.mcut), params.maskDark + 0.225 * (1. - params.maskDark) * mx));
        float adj = 0.8 * params.maskLight - 0.5 * (0.8 * params.maskLight - 1.) * mx + 0.75 * (1. - mx);
        mask = maskTmp;
        pos.x = fract(pos.x / 3.);
        if (pos.x < 0.333) mask.r = adj; else if (pos.x < 0.666) mask.g = adj; else mask.b = adj;
    } else if (params.shadowMask == 7.) {
        float mc = 1. - params.CGWG;
        float mx = max(max(c.r, c.g), c.b);
        float maskTmp = min(1.6 * max(mx - params.mcut, 0.) / (1. - params.mcut), mc);
        mask = vec3(maskTmp);
        pos.x = fract(pos.x / 2.);
        if (pos.x < 0.5) mask = vec3(1. + 0.6 * (1. - mx));
    } else if (params.shadowMask == 8.) {
        float line = params.maskLight;
        float odd = 0.;
        if (fract(pos.x / 4.) < 0.5) odd = 1.;
        if (fract((pos.y + odd) / 2.) < 0.5) line = params.maskDark;
        pos.x = fract(pos.x / 2.);
        if (pos.x < 0.5) {
            mask.r = params.maskLight;
            mask.b = params.maskLight;
        } else mask.g = params.maskLight;
        mask *= line;
    } else if (params.shadowMask == 9.) {
        vec3 fragment_Mask = vec3(params.maskDark);
        float bright = params.maskLight;
        float left = 0.;
        if (fract(pos.x / 6.) < 0.5) left = 1.;
        float m = fract(pos.x / 3.);
        if (m < 0.3333) fragment_Mask.b = 0.9; else if (m < 0.6666) fragment_Mask.g = 0.9; else fragment_Mask.r = 0.9;
        if (mod(pos.y, 2.) == 1. && left == 1. || mod(pos.y, 2.) == 0. && left == 0.) fragment_Mask *= bright;
        return fragment_Mask;
    } else if (params.shadowMask == 10.) {
        vec3 fragment_Mask = vec3(params.maskDark);
        float line = params.maskLight;
        float odd = 0.;
        if (fract(pos.x / 6.) < 0.5) odd = 1.;
        if (fract((pos.y + odd) / 2.) < 0.5) line = 1.;
        float m = fract(pos.x / 3.);
        float y = fract(pos.y / 2.);
        if (m > 0.3333) {
            fragment_Mask.r = 1.;
            fragment_Mask.b = 1.;
        } else if (m > 0.6666) fragment_Mask.g = 1.; else fragment_Mask = vec3(params.mcut);
        if (m > 0.333) fragment_Mask *= line;
        return fragment_Mask;
    }
    return mask;
}

mat3 fragment_vign(float l) {
    vec2 vpos = vTexCoord;
    vpos *= 1. - vpos.xy;
    float vig = vpos.x * vpos.y * 45.;
    vig = min(pow(vig, 0.15), 1.);
    if (params.vignette == 0.) vig = 1.;
    return mat3(vig, 0, 0, 0, vig, 0, 0, 0, vig);
}

vec2 fragment_Warp(vec2 pos) {
    pos = pos * 2. - 1.;
    pos *= vec2(1. + pos.y * pos.y * params.warpX, 1. + pos.x * pos.x * params.warpY);
    return pos * 0.5 + 0.5;
}

void fragment_main() {
    vec2 pos = fragment_Warp(vTexCoord);
    vec2 OGL2Pos = pos * params.SourceSize.xy;
    vec2 fp = fract(OGL2Pos);
    vec2 ps = params.SourceSize.zw;
    vec2 dx = vec2(ps.x, 0.);
    vec2 dy = vec2(0., ps.y);
    vec2 pC4 = floor(OGL2Pos) * ps + 0.5 * ps;
    float f = fp.y;
    if (params.OriginalSize.y > 400.) f = 1.;
    vec3 color;
    vec3 ul = texture(Source, pC4).xyz;
    vec3 ur = texture(Source, pC4 - dx).xyz;
    vec3 dl = texture(Source, pC4 + dy).xyz;
    vec3 dr = texture(Source, pC4 + vec2(-ps.x, ps.y)).xyz;
    float lx = fp.x;
    lx = pow(lx, params.h_sharp);
    float rx = 1. - fp.x;
    rx = pow(rx, params.h_sharp);
    vec3 color1 = (ur * rx + ul * lx) / (lx + rx);
    vec3 color2 = (dr * rx + dl * lx) / (lx + rx);
    color1 *= color1;
    color2 *= color2;
    float lum = dot(color1, vec3(0.3, 0.6, 0.1));
    float lum2 = dot(color2, vec3(0.3, 0.6, 0.1));
    float v = 0.;
    if (params.vignette > 0.) {
        v = vTexCoord.x - 0.5;
        v = v * v;
    }
    color = color1 * fragment_sw(f, lum, v) + color2 * fragment_sw(1. - f, lum2, v);
    color = color * fragment_Mask(vTexCoord * params.OutputSize.xy, color);
    color = pow(color, vec3(params.gamma_out));
    float s = dot(vec3(0.3, 0.6, 0.1), color);
    color *= mix(1., params.brightboost, lum);
    color = mix(vec3(s), color, params.sat);
    FragColor.rgb = color;
}

vec4 hook() {
    vertex_main();
    fragment_main();
    return delinearize(FragColor);
}

