// Generated by mpv-libretro

//!PARAM BGR_LCD_PATTERN
//!DESC BGR output pattern
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0

//!PARAM BLUR_OFFSET
//!DESC Blur Intensity
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0.5

//!PARAM BRIGHTNESS
//!DESC Scanline Intensity
//!TYPE CONSTANT float
//!MINIMUM 0.05
//!MAXIMUM 1
0.5

//!PARAM CURVATURE_X
//!DESC Screen curvature - horizontal
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0.1

//!PARAM CURVATURE_Y
//!DESC Screen curvature - vertical
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0.15

//!PARAM HORIZONTAL_BLUR
//!DESC Horizontal Blur
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0

//!PARAM SHRINK
//!DESC Shrink screen
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0

//!PARAM VERTICAL_BLUR
//!DESC Vertical Blur
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0

//!HOOK MAIN
//!COMPONENTS 4
//!DESC sRGB to linear RGB
//!SAVE MAIN_RGB
//!BIND HOOKED

vec4 hook() {
	return linearize(HOOKED_tex(HOOKED_pos));
}

//!HOOK MAIN
//!COMPONENTS 4
//!DESC gizmo-crt.slang
//!WIDTH OUTPUT.width 1 *
//!HEIGHT OUTPUT.height 1 *
//!BIND HOOKED
//!BIND MAIN_RGB

vec4 vertex_gl_Position;
struct _params_ {
    vec4 SourceSize;
    vec4 OriginalSize;
    vec4 OutputSize;
    uint FrameCount;
    float CURVATURE_X;
    float CURVATURE_Y;
    float BRIGHTNESS;
    float HORIZONTAL_BLUR;
    float VERTICAL_BLUR;
    float BLUR_OFFSET;
    float BGR_LCD_PATTERN;
    float SHRINK;
} params = _params_(vec4(MAIN_RGB_size, MAIN_RGB_pt), vec4(MAIN_RGB_size, MAIN_RGB_pt), vec4(target_size, 1. / target_size.x, 1. / target_size.y), uint(frame), float(CURVATURE_X), float(CURVATURE_Y), float(BRIGHTNESS), float(HORIZONTAL_BLUR), float(VERTICAL_BLUR), float(BLUR_OFFSET), float(BGR_LCD_PATTERN), float(SHRINK));
struct _global_ {
    mat4 MVP;
} global = _global_(mat4(1.));
vec4 Position = vec4(HOOKED_pos, 0., 1.);
vec2 TexCoord = HOOKED_pos;
vec2 vTexCoord;
void vertex_main() {
    vertex_gl_Position = global.MVP * Position;
    vTexCoord = TexCoord;
}

vec4 FragColor;
#define Source MAIN_RGB_raw
float fragment_PHI = 1.618034;
float fragment_gold_noise(in vec2 xy, in float seed) {
    return fract(tan(distance(xy * fragment_PHI, xy) * seed) * xy.x);
}

vec2 fragment_saturateA(in vec2 x) {
    return clamp(x, 0., 1.);
}

vec2 fragment_magnify(in vec2 uv, in vec2 res) {
    uv *= res;
    return (fragment_saturateA(fract(uv) / fragment_saturateA(fwidth(uv))) + floor(uv) - 0.5) / res.xy;
}

vec4 fragment_textureVertical(in vec2 uv) {
    vec2 texSize = vec2(textureSize(Source, 0));
    uv = fragment_magnify(uv, texSize.xy);
    uv = uv * texSize.xy + 0.5;
    vec2 iuv = floor(uv);
    vec2 fuv = uv - iuv;
    if (params.HORIZONTAL_BLUR == 1.) {
        vec2 uv1 = vec2(uv + vec2(-0.5, -0.5)) / texSize.xy;
        vec2 uv2 = vec2(uv + vec2(-0.5 + params.BLUR_OFFSET, -0.5)) / texSize.xy;
        vec4 col1 = texture(Source, uv1);
        vec4 col2 = texture(Source, uv2);
        vec4 col = (col1 + col2) / vec4(2.);
        if (params.VERTICAL_BLUR == 1.) {
            vec2 uv3 = vec2(uv + vec2(-0.5, -0.5 + params.BLUR_OFFSET)) / texSize.xy;
            vec2 uv4 = vec2(uv + vec2(-0.5 + params.BLUR_OFFSET, -0.5 + params.BLUR_OFFSET)) / texSize.xy;
            vec4 col3 = texture(Source, uv3);
            vec4 col4 = texture(Source, uv4);
            col = ((col3 + col4) / vec4(2.) + col) / vec4(2.);
        }
        return col;
    } else {
        uv = vec2(uv + vec2(-0.5, -0.5)) / texSize.xy;
        return texture(Source, uv);
    }
}

vec4 fragment_textureCRT(in vec2 uvr, in vec2 uvg, in vec2 uvb) {
    return vec4(fragment_textureVertical(uvr).r, fragment_textureVertical(uvg).g, fragment_textureVertical(uvb).b, 255);
}

float fragment_GetFuv(in vec2 uv) {
    vec2 texSize = vec2(textureSize(Source, 0));
    uv = uv * texSize.xy + 0.5;
    vec2 iuv = floor(uv);
    vec2 fuv = uv - iuv;
    return abs((fuv * fuv * fuv * (fuv * (fuv * 6. - 15.) + 10.)).y - 0.5);
}

vec2 fragment_GetIuv(in vec2 uv) {
    vec2 texSize = vec2(textureSize(Source, 0));
    uv = uv * texSize.xy;
    vec2 iuv = floor(uv);
    return iuv;
}

vec4 fragment_AddNoise(in vec4 col, in vec2 coord) {
    float iGlobalTime = float(params.FrameCount) * 0.025;
    return clamp(col + fragment_gold_noise(coord, sin(iGlobalTime)) / 32. - 1. / 64., 0., 1.);
}

vec4 fragment_AddScanlines(in vec4 col, in vec2 coord) {
    vec2 texSize = vec2(textureSize(Source, 0));
    float brightness = 1. / params.BRIGHTNESS * 0.05;
    float scale = params.OutputSize.y / texSize.y * 0.5;
    float dim = brightness * scale;
    col.rgb -= dim * abs(1.5 * (1. - col.rgb) * abs(abs(fragment_GetFuv(coord) - 0.5)));
    return col;
}

vec3 fragment_XCoords(in float coord, in float factor) {
    float iGlobalTime = float(params.FrameCount) * 0.025;
    float spread = 0.333;
    vec3 coords = vec3(coord);
    if (params.BGR_LCD_PATTERN == 1.) coords.r += spread * 2.; else coords.b += spread * 2.;
    coords.g += spread;
    coords *= factor;
    return coords;
}

float fragment_YCoord(in float coord, in float factor) {
    return coord * factor;
}

vec2 fragment_CURVATURE_DISTORTION = vec2(params.CURVATURE_X, params.CURVATURE_Y);
vec2 fragment_barrelScale = 1. - 0.23 * fragment_CURVATURE_DISTORTION;
vec2 fragment_Distort(vec2 coord) {
    coord -= vec2(0.5);
    float rsq = coord.x * coord.x + coord.y * coord.y;
    coord += coord * (fragment_CURVATURE_DISTORTION * rsq);
    coord *= fragment_barrelScale;
    if (abs(coord.x) >= 0.5 || abs(coord.y) >= 0.5) coord = vec2(-1.); else {
        coord += vec2(0.5);
    }
    return coord;
}

void fragment_main() {
    vec2 texSize = vec2(textureSize(Source, 0));
    vec2 texcoord = vTexCoord.xy;
    if (params.SHRINK > 0.) {
        texcoord.y -= 0.5;
        texcoord.y *= 1. + params.SHRINK;
        texcoord.y += 0.5;
    }
    texcoord = fragment_Distort(texcoord);
    if (texcoord.x < 0.) {
        FragColor = vec4(0.);
        return;
    }
    vec2 fragCoord = texcoord.xy * params.OutputSize.xy;
    vec2 factor = texSize.xy / params.OutputSize.xy;
    highp float yCoord = fragment_YCoord(fragCoord.y, factor.y);
    highp vec3 xCoords = fragment_XCoords(fragCoord.x, factor.x);
    vec2 coord_r = vec2(xCoords.r / texSize.x, texcoord.y);
    vec2 coord_g = vec2(xCoords.g, yCoord) / texSize.xy;
    vec2 coord_b = vec2(xCoords.b, yCoord) / texSize.xy;
    FragColor = fragment_textureCRT(coord_r, coord_g, coord_b);
    FragColor = fragment_AddNoise(FragColor, fragCoord);
    FragColor = fragment_AddScanlines(FragColor, coord_r);
    FragColor.a = 1.;
}

vec4 hook() {
    vertex_main();
    fragment_main();
    return delinearize(FragColor);
}

