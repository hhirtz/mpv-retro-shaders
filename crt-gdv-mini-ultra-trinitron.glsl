// Generated by mpv-libretro

//!PARAM CGWG
//!DESC   CGWG Mask Str.
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
1

//!PARAM beam_max
//!DESC Scanline Bright
//!TYPE CONSTANT float
//!MINIMUM 0.5
//!MAXIMUM 3
2

//!PARAM beam_min
//!DESC Scanline Dark
//!TYPE CONSTANT float
//!MINIMUM 0.5
//!MAXIMUM 3
1.5

//!PARAM brightboost
//!DESC   Bright boost
//!TYPE CONSTANT float
//!MINIMUM 0.5
//!MAXIMUM 2
1.2

//!PARAM gamma_out_blue
//!DESC   Gamma out Blue
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 4
2.2

//!PARAM gamma_out_green
//!DESC   Gamma out Green
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 4
2.2

//!PARAM gamma_out_red
//!DESC   Gamma out Red
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 4
2.2

//!PARAM gdv_B
//!DESC Mono Blue/Channel
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 2
1

//!PARAM gdv_G
//!DESC Mono Green/Channel
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 2
1

//!PARAM gdv_R
//!DESC Mono Red/Channel
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 2
1

//!PARAM gdv_mono
//!DESC Mono Display On/Off
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0

//!PARAM glow
//!DESC Glow Strength
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
0.35

//!PARAM h_sharp
//!DESC Horizontal Sharpness
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 5
2.5

//!PARAM maskDark
//!DESC   Lottes maskDark
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 2
0

//!PARAM maskLight
//!DESC   Lottes maskLight
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 2
1.5

//!PARAM masksize
//!DESC   CRT Mask Size (2.0 is nice in 4k)
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 2
1

//!PARAM mcut
//!DESC   Mask 5-7-10 cutoff
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 0.5
0.2

//!PARAM sat
//!DESC   Saturation adjustment
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 2
1.2

//!PARAM scanline
//!DESC Scanline Adjust
//!TYPE CONSTANT float
//!MINIMUM 1
//!MAXIMUM 15
10

//!PARAM shadowMask
//!DESC   CRT Mask: 0:CGWG, 1-4:Lottes, 5-6:Trinitron
//!TYPE CONSTANT float
//!MINIMUM -1
//!MAXIMUM 11
11

//!PARAM thres
//!DESC   Mask Effect Threshold
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 0.9
0.4

//!PARAM vignette
//!DESC Vignette On/Off
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 1
1

//!PARAM warpX
//!DESC CurvatureX (default 0.03)
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 0.25
0

//!PARAM warpY
//!DESC CurvatureY (default 0.04)
//!TYPE CONSTANT float
//!MINIMUM 0
//!MAXIMUM 0.25
0.05

//!HOOK MAIN
//!COMPONENTS 4
//!DESC sRGB to linear RGB
//!SAVE MAIN_RGB
//!BIND HOOKED

vec4 hook() {
	return linearize(HOOKED_tex(HOOKED_pos));
}

//!HOOK MAIN
//!COMPONENTS 2
//!DESC store viewport size
//!SAVE VIEWPORT
//!WIDTH OUTPUT.width
//!HEIGHT OUTPUT.width

vec4 hook() {
	return vec4(target_size, 0.0, 0.0);
}

//!HOOK MAIN
//!COMPONENTS 4
//!DESC crt-gdv-mini-ultra.slang
//!WIDTH OUTPUT.width 1 *
//!HEIGHT OUTPUT.height 1 *
//!BIND MAIN_RGB
//!BIND VIEWPORT
//!BIND HOOKED

vec4 vertex_gl_Position;
struct _params_ {
    float brightboost;
    float sat;
    float glow;
    float scanline;
    float beam_min;
    float beam_max;
    float h_sharp;
    float shadowMask;
    float masksize;
    float mcut;
    float maskDark;
    float maskLight;
    float CGWG;
    float warpX;
    float warpY;
    float gamma_out_red;
    float gamma_out_green;
    float gamma_out_blue;
    float vignette;
    float gdv_mono;
    float gdv_R;
    float gdv_G;
    float gdv_B;
    float thres;
} params = _params_(float(brightboost), float(sat), float(glow), float(scanline), float(beam_min), float(beam_max), float(h_sharp), float(shadowMask), float(masksize), float(mcut), float(maskDark), float(maskLight), float(CGWG), float(warpX), float(warpY), float(gamma_out_red), float(gamma_out_green), float(gamma_out_blue), float(vignette), float(gdv_mono), float(gdv_R), float(gdv_G), float(gdv_B), float(thres));
struct _global_ {
    mat4 MVP;
    vec4 FinalViewportSize;
    vec4 OutputSize;
    vec4 SourceSize;
    vec4 OriginalSize;
} global = _global_(mat4(1.), vec4(VIEWPORT_size, VIEWPORT_pt), vec4(target_size, 1. / target_size.x, 1. / target_size.y), vec4(MAIN_RGB_size, MAIN_RGB_pt), vec4(MAIN_RGB_size, MAIN_RGB_pt));
vec4 Position = vec4(HOOKED_pos, 0., 1.);
vec2 TexCoord = HOOKED_pos;
vec2 vTexCoord;
void vertex_main() {
    vertex_gl_Position = global.MVP * Position;
    vTexCoord = TexCoord * 1.0001;
}

vec4 FragColor;
#define Source MAIN_RGB_raw
float fragment_sw(float x, float l) {
    float d = x;
    float bm = params.scanline;
    float b = mix(params.beam_min, params.beam_max, l);
    d = exp2(-bm * pow(d, b));
    return d;
}

vec3 fragment_toGrayscale(vec3 color) {
    float average = (color.r + color.g + color.b) / 3.;
    return vec3(average);
}

vec3 fragment_colorize(vec3 grayscale, vec3 color) {
    return grayscale * color;
}

vec3 fragment_Mask(vec2 pos, vec3 c) {
    pos = floor(pos / params.masksize);
    vec3 mask = vec3(params.maskDark, params.maskDark, params.maskDark);
    if (params.shadowMask == -1.) {
        mask = vec3(1.);
    } else if (params.shadowMask == 0.) {
        pos.x = fract(pos.x * 0.5);
        float mc = 1. - params.CGWG;
        if (pos.x < 0.5) {
            mask.r = 1.1;
            mask.g = mc;
            mask.b = 1.1;
        } else {
            mask.r = mc;
            mask.g = 1.1;
            mask.b = mc;
        }
    } else if (params.shadowMask == 1.) {
        float line = params.maskLight;
        float odd = 0.;
        if (fract(pos.x / 6.) < 0.5) odd = 1.;
        if (fract((pos.y + odd) / 2.) < 0.5) line = params.maskDark;
        pos.x = fract(pos.x / 3.);
        if (pos.x < 0.333) mask.b = params.maskLight; else if (pos.x < 0.666) mask.g = params.maskLight; else mask.r = params.maskLight;
        mask *= line;
    } else if (params.shadowMask == 2.) {
        pos.x = fract(pos.x / 3.);
        if (pos.x < 0.333) mask.b = params.maskLight; else if (pos.x < 0.666) mask.g = params.maskLight; else mask.r = params.maskLight;
    } else if (params.shadowMask == 3.) {
        pos.x += pos.y * 3.;
        pos.x = fract(pos.x / 6.);
        if (pos.x < 0.333) mask.b = params.maskLight; else if (pos.x < 0.666) mask.g = params.maskLight; else mask.r = params.maskLight;
    } else if (params.shadowMask == 4.) {
        pos.xy = floor(pos.xy * vec2(1., 0.5));
        pos.x += pos.y * 3.;
        pos.x = fract(pos.x / 6.);
        if (pos.x < 0.333) mask.b = params.maskLight; else if (pos.x < 0.666) mask.g = params.maskLight; else mask.r = params.maskLight;
    } else if (params.shadowMask == 5.) {
        float mx = max(max(c.r, c.g), c.b);
        vec3 maskTmp = vec3(min(1.25 * max(mx - params.mcut, 0.) / (1. - params.mcut), params.maskDark + 0.2 * (1. - params.maskDark) * mx));
        float adj = 0.8 * params.maskLight - 0.5 * (0.8 * params.maskLight - 1.) * mx + 0.75 * (1. - mx);
        mask = maskTmp;
        pos.x = fract(pos.x / 2.);
        if (pos.x < 0.5) {
            mask.r = adj;
            mask.b = adj;
        } else mask.g = adj;
    } else if (params.shadowMask == 6.) {
        float mx = max(max(c.r, c.g), c.b);
        vec3 maskTmp = vec3(min(1.33 * max(mx - params.mcut, 0.) / (1. - params.mcut), params.maskDark + 0.225 * (1. - params.maskDark) * mx));
        float adj = 0.8 * params.maskLight - 0.5 * (0.8 * params.maskLight - 1.) * mx + 0.75 * (1. - mx);
        mask = maskTmp;
        pos.x = fract(pos.x / 3.);
        if (pos.x < 0.333) mask.r = adj; else if (pos.x < 0.666) mask.g = adj; else mask.b = adj;
    } else if (params.shadowMask == 7.) {
        float mc = 1. - params.CGWG;
        float mx = max(max(c.r, c.g), c.b);
        float maskTmp = min(1.6 * max(mx - params.mcut, 0.) / (1. - params.mcut), mc);
        mask = vec3(maskTmp);
        pos.x = fract(pos.x / 2.);
        if (pos.x < 0.5) mask = vec3(1. + 0.6 * (1. - mx));
    } else if (params.shadowMask == 8.) {
        float line = params.maskLight;
        float odd = 0.;
        if (fract(pos.x / 4.) < 0.5) odd = 1.;
        if (fract((pos.y + odd) / 2.) < 0.5) line = params.maskDark;
        pos.x = fract(pos.x / 2.);
        if (pos.x < 0.5) {
            mask.r = params.maskLight;
            mask.b = params.maskLight;
        } else mask.g = params.maskLight;
        mask *= line;
    } else if (params.shadowMask == 9.) {
        vec3 fragment_Mask = vec3(params.maskDark);
        float bright = params.maskLight;
        float left = 0.;
        if (fract(pos.x / 6.) < 0.5) left = 1.;
        float m = fract(pos.x / 3.);
        if (m < 0.3333) fragment_Mask.b = 0.9; else if (m < 0.6666) fragment_Mask.g = 0.9; else fragment_Mask.r = 0.9;
        if (mod(pos.y, 2.) == 1. && left == 1. || mod(pos.y, 2.) == 0. && left == 0.) fragment_Mask *= bright;
        return fragment_Mask;
    } else if (params.shadowMask == 10.) {
        vec3 fragment_Mask = vec3(params.maskDark);
        float line = params.maskLight;
        float odd = 0.;
        if (fract(pos.x / 6.) < 0.5) odd = 1.;
        if (fract((pos.y + odd) / 2.) < 0.5) line = 1.;
        float m = fract(pos.x / 3.);
        float y = fract(pos.y / 2.);
        if (m > 0.3333) {
            fragment_Mask.r = 1.;
            fragment_Mask.b = 1.;
        } else if (m > 0.6666) fragment_Mask.g = 1.; else fragment_Mask = vec3(params.mcut);
        if (m > 0.333) fragment_Mask *= line;
        return fragment_Mask;
    } else if (params.shadowMask == 11.) {
        vec3 fragment_Mask = vec3(params.maskDark);
        pos.x = fract(pos.x / 3.);
        if (pos.x > 0.333) fragment_Mask = vec3(1.);
        return fragment_Mask;
    }
    return mask;
}

mat3 fragment_vign(float l) {
    vec2 vpos = vTexCoord;
    vpos *= 1. - vpos.xy;
    float vig = vpos.x * vpos.y * 45.;
    vig = min(pow(vig, 0.15), 1.);
    if (params.vignette == 0.) vig = 1.;
    return mat3(vig, 0, 0, 0, vig, 0, 0, 0, vig);
}

vec2 fragment_Warp(vec2 pos) {
    pos = pos * 2. - 1.;
    pos *= vec2(1. + pos.y * pos.y * params.warpX, 1. + pos.x * pos.x * params.warpY);
    return pos * 0.5 + 0.5;
}

vec3 fragment_saturation(vec3 textureColor) {
    float lum = length(textureColor.rgb) * 0.5775;
    vec3 luminanceWeighting = vec3(0.3, 0.6, 0.1);
    if (lum < 0.5) luminanceWeighting.rgb = luminanceWeighting.rgb * luminanceWeighting.rgb + luminanceWeighting.rgb * luminanceWeighting.rgb;
    float luminance = dot(textureColor.rgb, luminanceWeighting);
    vec3 greyScaleColor = vec3(luminance);
    vec3 color1 = vec3(mix(greyScaleColor, textureColor.rgb, params.sat));
    return color1;
}

vec3 fragment_glow0(vec2 texcoord, vec3 col) {
    vec3 sum = vec3(0.);
    vec2 blurSize = vec2(global.SourceSize.zw);
    vec3 c20 = texture(Source, vec2(texcoord.x - 2. * blurSize.x, texcoord.y)).rgb;
    c20 * c20;
    vec3 c10 = texture(Source, vec2(texcoord.x - blurSize.x, texcoord.y)).rgb;
    c10 * c10;
    vec3 c11 = texture(Source, vec2(texcoord.x, texcoord.y)).rgb;
    c11 * c11;
    vec3 c12 = texture(Source, vec2(texcoord.x + blurSize.x, texcoord.y)).rgb;
    c12 * c12;
    vec3 c21 = texture(Source, vec2(texcoord.x + 2. * blurSize.x, texcoord.y)).rgb;
    c21 * c21;
    vec3 c22 = texture(Source, vec2(texcoord.x - 2. * blurSize.x, texcoord.y - blurSize.y)).rgb;
    c22 * c22;
    vec3 c23 = texture(Source, vec2(texcoord.x - blurSize.x, texcoord.y - 2. * blurSize.y)).rgb;
    c23 * c23;
    vec3 c13 = texture(Source, vec2(texcoord.x - blurSize.x, texcoord.y - blurSize.y)).rgb;
    c13 * c13;
    vec3 c14 = texture(Source, vec2(texcoord.x + blurSize.x, texcoord.y + blurSize.y)).rgb;
    c14 * c14;
    vec3 c24 = texture(Source, vec2(texcoord.x + blurSize.x, texcoord.y + 2. * blurSize.y)).rgb;
    c24 * c24;
    vec3 c25 = texture(Source, vec2(texcoord.x + 2. * blurSize.x, texcoord.y + blurSize.y)).rgb;
    c25 * c25;
    vec3 c26 = texture(Source, vec2(texcoord.x - 2. * blurSize.x, texcoord.y + blurSize.y)).rgb;
    c26 * c26;
    vec3 c27 = texture(Source, vec2(texcoord.x - blurSize.x, texcoord.y + 2. * blurSize.y)).rgb;
    c27 * c27;
    vec3 c15 = texture(Source, vec2(texcoord.x - blurSize.x, texcoord.y + blurSize.y)).rgb;
    c15 * c15;
    vec3 c16 = texture(Source, vec2(texcoord.x + blurSize.x, texcoord.y - blurSize.y)).rgb;
    c16 * c16;
    vec3 c28 = texture(Source, vec2(texcoord.x + blurSize.x, texcoord.y - 2. * blurSize.y)).rgb;
    c28 * c28;
    vec3 c29 = texture(Source, vec2(texcoord.x + 2. * blurSize.x, texcoord.y - blurSize.y)).rgb;
    c29 * c29;
    vec3 c30 = texture(Source, vec2(texcoord.x, texcoord.y - 2. * blurSize.y)).rgb;
    c30 * c30;
    vec3 c17 = texture(Source, vec2(texcoord.x, texcoord.y - blurSize.y)).rgb;
    c17 * c17;
    vec3 c18 = texture(Source, vec2(texcoord.x, texcoord.y + blurSize.y)).rgb;
    c18 * c18;
    vec3 c31 = texture(Source, vec2(texcoord.x, texcoord.y + 2. * blurSize.y)).rgb;
    c31 * c31;
    sum = (3. * c11 + 2.5 * (c10 + c12 + c13 + c14 + c15 + c16 + c17 + c18) + 1.5 * (c20 + c21 + c22 + c23 + c24 + c25 + c26 + c27 + c28 + c29 + c30 + c31)) / 45.;
    return sum * params.glow;
}

void fragment_main() {
    vec2 pos = fragment_Warp(vTexCoord);
    vec4 SourceSize = global.SourceSize;
    vec2 ps = SourceSize.zw;
    vec2 OGL2Pos = pos * SourceSize.xy;
    vec2 fp = fract(OGL2Pos);
    vec2 dx = vec2(ps.x, 0.);
    vec2 dy = vec2(0., ps.y);
    vec2 pC4 = floor(OGL2Pos) * ps + 0.5 * ps;
    vec3 ul = texture(Source, pC4).xyz;
    vec3 ur = texture(Source, pC4 + dx).xyz;
    vec3 dl = texture(Source, pC4 + dy).xyz;
    vec3 dr = texture(Source, pC4 + ps).xyz;
    float lx = fp.x;
    lx = pow(lx, params.h_sharp);
    float rx = 1. - fp.x;
    rx = pow(rx, params.h_sharp);
    vec3 color1 = (ur * lx + ul * rx) / (lx + rx);
    vec3 color2 = (dr * lx + dl * rx) / (lx + rx);
    float f = fp.y;
    float luma1 = color1.r * 0.3 + color1.g * 0.6 + color1.b * 0.1;
    float luma2 = color2.r * 0.3 + color2.g * 0.6 + color2.b * 0.1;
    color1 = 2. * pow(color1, vec3(2.8)) - pow(color1, vec3(3.6));
    color2 = 2. * pow(color2, vec3(2.8)) - pow(color2, vec3(3.6));
    color1 = color1 * mix(fragment_Mask(vTexCoord * global.OutputSize.xy, color1), vec3(1.), luma1 * params.thres);
    color2 = color2 * mix(fragment_Mask(vTexCoord * global.OutputSize.xy, color2), vec3(1.), luma2 * params.thres);
    vec3 color = color1 * fragment_sw(f, luma1) + color2 * fragment_sw(1. - f, luma2);
    vec4 OriginalSize = global.OriginalSize;
    if (OriginalSize.y >= 400.) {
        color = (color1 + color2) / 2.;
    }
    color = min(color, 1.);
    float lum = color.r * 0.3 + color.g * 0.6 + color.b * 0.1;
    color = pow(color, vec3(1. / params.gamma_out_red, 1., 1.));
    color = pow(color, vec3(1., 1. / params.gamma_out_green, 1.));
    color = pow(color, vec3(1., 1., 1. / params.gamma_out_blue));
    color += fragment_glow0(pC4, color);
    color *= mix(1., params.brightboost, lum);
    color = fragment_saturation(color);
    color *= fragment_vign(lum);
    if (params.gdv_mono == 1.) {
        vec3 col1 = fragment_toGrayscale(color);
        vec3 c = vec3(params.gdv_R, params.gdv_G, params.gdv_B);
        color = fragment_colorize(col1, c);
    } else color = color;
    FragColor = vec4(color, 1.);
}

vec4 hook() {
    vertex_main();
    fragment_main();
    return delinearize(FragColor);
}

